# 음료수 얼려먹기

# 풀이 방법
# 배열 내 모든 원소 중 구멍이 뚫려 있는 원소들에 대해 탐색 시작
# 탐색한 횟수를 반환

# 예시
# 4 5
# 00110 > 2군데(1번째, 5번째)
# 00011
# 11111
# 00000 > 1군데(1번째)

# 0이 3군데에 한하여 나뉘어 있으므로 3

# 15 14
# 00000111100000 > 2군데(1번째, 11번째)
# 11111101111110 > 1군데(8번째)
# 11011101101110 > 1군데(3번째)
# 11011101100000
# 11011111111111
# 11011111111100 > 1군데(13번째)
# 11000000011111
# 01111111111111 > 1군데(1번째)
# 00000000011111
# 01111111111000 > 1군데(12번째)
# 00011111111000
# 00000001111000
# 11111111110011
# 11100011111111 > 1군데(4번째)
# 11100011111111

# 0이 8군데에 한하여 나뉘어 있으므로 8

# 풀이
# 재귀함수 이용 DFS 구현

# 교재 내에 있는 풀이 방식
# 입력을 받아온 위치가 0이라면(구멍이 뚫려있었거나 아직 방문을 안했거나) 탐색 시작
# 해당위치 기준 상하좌우로 탐색
# 만약 해당위치가 2차원 리스트의 범위를 벗어난다면 탐색 불가
# 해당 함수의 출력 값을 True, False로 하여 나중에 모든 원소에 대해 DFS 탐색이 가능한지 여부를 반환
def DFS(r, c):
    if r < 0 or r > N - 1 or c < 0 or c > M - 1:
        return False
    if ice_cream[r][c] == 0:
        ice_cream[r][c] = 1

        DFS(r + 1, c)
        DFS(r, c + 1)
        DFS(r - 1, c)
        DFS(r, c - 1)
        return True
    else:
        return False

# N(행) X M(열) 2차원 리스트 생성
N, M = map(int, input().split(' '))

# 2차원 리스트 정보 입력받기
ice_cream = [[int(x) for x in input()] for _ in range(N)]

answer = 0

# 모든 원소들에 대해서 DFS 실시
# 만약 해당 위치가 구멍이 뚫려 있지 않다면 다음 위치로 이동하여 실시
for n in range(N):
    for m in range(M):
        if DFS(n, m):
            answer += 1
print(answer)