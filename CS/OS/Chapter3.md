# 프로세스와 프로그램
- 프로그램: 하드디스크 같은 저장장치에 보관, 마우스로 더블클릭하면 실행
- 프로세스: 실행을 위해 메모리에 올라온 동적인 상태
- 프로세스: 프로그램 + PCB(프로세스 제어 블록)

<br><br>

# 프로세스 제어 블록
- 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터, 각종 레지스터 중간값 등을 관리
- 자신, 부모, 자식 프로세스 구분자(PID, PPID, CPID): 각 프로세스를 구분하는 구분자
- 프로세스 상태: 현재 프로세스가 어떤 상태인지
- 프로그램 카운터: 다음에 실행될 명령어 위치
- 프로세스 우선순위: 대기 큐에서의 우선순위
- 각종 레지스터 정보: 누산기, 색인 레지스터, 스택 포인터와 같은 레지스터 값(중간값) 저장
- 메모리 관리 정보: 프로세스의 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터, 한계 레지스터 값, 세그멘테이션 혹은 페이지 테이블 등
- 할당된 자원 정보: 입출력 자원 혹은 오픈 파일 등에 대한 정보
- 계정 정보: 계정 번호, CPU 할당 시간, CPU 사용 시간

<br><br>

# 프로세스의 상태
- 활성 상태: 생성, 준비, 실행 ,대기, 완료 상태
- 보류 상태: 보류 대기 상태, 보류 준비 상태
- 보류 상태에 들어간 프로세스는 스왑 영역에 보관
  - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
  - 프로그램 오류로 인한 실행을 미룰 때
  - 바이러스와 같은 악의적인 공격 의심
  - 입출력이 계속 지연될 때
- 그림은 p.145 참고
- 이 외 정지상태가 존재하며 `ctrl + z`명령어를 통해 프로세스를 일시 정지, `jobs`로 프로세스 상태 확인, `bg` 혹은 `fg`로 재시작

<br><br>

# 문맥 교환
- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
- 작업을 진행하던 PCB는 지금까지의 작업 내용을 저장, 실행 상태로 들어오는 PCB의 내용으로 CPU가 다시 세팅
- 그림은 p.150 참고
- 자신에게 주어진 시간을 다 사용할 때, 인터럽트 발생 시 문맥교환 발생

<br><br>

# 프로세스의 구조
- 코드 영역: 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 함(작성한 프로그램이 탑재, 읽기 전용)
- 데이터 영역: 코드 실행시 사용하는 변수, 파일 등의 데이터를 모아놓은 곳
- 힙 영역: 동적으로 할당되는 변수에 대한 데이터를 모아놓은 곳
- 스택 영역: 부수적인 데이터를 모아놓은 곳(함수 수행 후 원래 프로그램으로 되돌아올 위치), **사용자에게 보이지 않는 영역**

<br><br>

# 스레드
- 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위
- 운영체제 입장에서의 작업 단위는 프로세스, CPU 입장에서의 작업 단위는 스레드
- 프로세스끼리는 약하게 연결(서로 독립적) 스레드끼리는 강하게 연결(일부 메모리 영역, 작업 순서를 공유하는 종속적)

<br><br>

# 멀티스레드의 구조
- 멀티스레드는 멀티태스킹의 낭비 요소를 제거하기 위해 사용<br>
  (비슷한 일을 하는 2개의 프로세스 대신 코드, 데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스에서 수행)
- 각각의 스레드는 프로세스의 정적 영역을 공유하지만 각각의 독립적인 스택 영역, 힙 영역, 레지스터 값 등(동적 영역)을 가짐
- 그림은 p.170 참고

<br><br>

# 멀티스레드의 장단점
### 장점
- 응답성 향상: 한 스레드가 입출력으로 인해 작업이 진행되지 않아도 다른 스레드가 작업하여 작업 요구에 빠르게 응답
- 자원 공유: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유
- 효율성 향상: 여러 개의 프로세스를 생성하는 것과 달리 멀티 스레드는 불필요한 자원의 중복을 막음
- 다중 CPU 지원: CPU 사용량이 증가, 프로세스 처리 시간이 단축

<br>

### 단점
- 멀티스레드의 경우 하나의 스레드에 문제가 생기면 전체 프로세스에 영향
- 인터넷 익스플로러(멀티스레드): 문제 있는 화면 강제 종료 > 인터넷 익스플로러 전체가 종료
- 크롬(멀티프로세스): 하나가 문제가 생겨 종료해도 다른 화면에 영향이 적음
- 과거와 달리 **요즘은 메모리 늘고, 멀티코어 CPU의 대중화되었기 때문에<br>
  여러 개의 프로세스를 여러 개의 CPU에서 동시 실행(멀티태스킹)**
