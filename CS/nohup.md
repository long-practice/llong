# nohup(no hang up)
- 리눅스에서 프로세스를 실행한 터미널의 세션 연결이 끊어지더라도 지속적으로 동작할 수 있게 해주는 명렁어
- 터미널에서 로그아웃 발생 시 리눅스는 해당 터미널에서 실행한 프로세스들에게 HUP 신호를 전달하여 종료
- HUP 신호를 프로세스가 무시하도록하는 명령어
- **터미널에서 연결이 끊기거나 터미널을 종료해도 실행했던 프로세스들이 계속 실행
<br>
<br>

# 사용방법
- 중단 없이 실행하고자 하는 프로그램 명령어 앞에 `nohup`
- 예를들어<br>
  ``` $ nohup python preprocess.py $ ```
- 이 때 nohup으로 실행시킬 파일은 반드시 755퍼미션을 가지고 있어야 함<br>
<br>
- `>` 혹은 `>>`와 같은 리다이렉션을 이용해서 다른 파일에 출력할 수 있음
- 어디에도 표준출력을 기록하고 싶지 않다면 `> /dev/null`
  ```
    nohup python preprocess.py > nohup_print.out // nohup_print.out 파일에 출력
    nohup python preprocess.py > /dev/null // 표준출력 기록하지 않음
  ```
<br>
<br>

### 리눅스 권한
- 파일을 서버에 전송하기 전 전송될 파일에 권한이 부여
- 크게 3가지로 파일의 권한을 부여할 수 있으며, **읽기(Reading), 쓰기(writing), 실행(executing)** 으로 분류
- 위 숫자는 각각 8진수로 나타냄(7의 경우 읽기(4) + 쓰기(2) + 실행(1) 모두 가능)
- 만약 777의 권한이 부여될 경우 각 자리는 누구에게 권한을 부여하는가를 나타냄<br>
  **소유자 권한, 그룹 사용자 권한, 기타 사용자 권한**을 의미
- 즉, 755의 권한이라면 소유자는 읽기, 쓰기, 실행이 가능하나 그 외 사용자는 쓰기만 불가능

### chmod
- `chmod` 명령어를 사용하여 파일 또는 디렉토리(폴더)에 권한을 부여, 수정 가능
- 만약 모든 사용자에 대해 읽기, 쓰기, 실행의 권한을 부여한다면 아래와 같은 명령어로 부여가능<br>
- `chmod [옵션] [권한] [파일 혹은 디렉토리]`
  ```
    chmod -R 777 file.py
  ```
- 위에서 `-R`은 모든 파일 혹은 디렉토리 내에 있는 파일들에 대해 순환적인 변화 지정

### chown
- 리눅스는 파일 및 경로에 소유자와 그룹 사용자를 지정 가능
- `chown [옵션] [사용자] [:그룹] [파일 혹은 디렉토리]`
- 위에서 사용자는 파일 혹은 디렉토리의 소유권을 가질 수 있는 새로운 사용자들을 나타냄
- 그룹은 파일 혹은 디렉토리와 연관이 있는 그룹으로 반드시 콜론(:)을 접두사로 가짐
- `-R`은 위와 동일

<br>
<br>

# & vs nohup
- `&`를 프로그램 실행시에 명령어 맨 끝에 붙여주면 해당 프로그램이 백그라운드로 실행
- nohup은 프로그램을 데몬의 형태로 실행시키므로 로그아웃으로 접속 세션이 종료되더라도 프로그램이 종료되지 않음
- `&`백그라운드 실행은 단지 프로그램을 사용자 눈에 보이지 않는 백그라운드 형태로 돌리고 있는 것<br>
  따라서 로그아웃으로 세션과 연결이 끊어지면 실행되고 있던 프로그램도 함께 종료

<br><br>
  
# 백그라운드에서 돌고 있는 프로세스 확인
- `ps -ef | grep py`명령어를 살펴보면
- `ps`: process status(프로세스 상태)
- 즉, 현재 실행중인 프로세스 목록과 상태를 보여줌
- `-e`옵션은 커널 프로세스를 제외한 모든 프로세스 출력
- `-f`옵션은 풀 포맷으로 보여줌(UID, PID 등이 함께 표시)
- grep은 원하는 프로세스를 찾을 때 이용하며, grep py는 py와 연관된 프로세스를 찾음

<br><br>

# 프로세스 종료
- `kill` 명령어로 프로세스를 종료
```
  kill -9 pid
```
- 이 때 **파일이름이 아닌 프로세스 아이디를 명령어에 입력해야 함**
